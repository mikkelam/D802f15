\subsection{Choosing features}\label{sec:choosingfeatures}
We first introduce some convenient notations that mathematically describes the concept of a game.
$C = \{1, 2, \dots, m\}$ is the set of all champions, where each champion is represented by an id. $m = 124$ for the data used in this project.
$P = \{p_1; p_2, \dots\}$ denotes the set of all players.
$T = \{T_\text{blue}$, $T_\text{purple}\}$ is a set containing the two teams \emph{blue} and \emph{purple} respectively.
$T_i = \{ (p_j, c_j) \in P \times C \mid c_j \text{ is controlled by } p_j \text{ on team } i \}$.

Some champions may be better than other champions, to capture the strength of individual champions, we will need a feature that represent the presence or absence of a particular champion on each team.
We define a feature $x_{\text{SINGLE}}$, such that $\forall t \in T, \forall c \in C:$
\[
x_{\text{SINGLE}}(t, c) = 
\begin{cases} 
  1 & \text{if } (c, p) \in t \text{ for some } p \\
  0 & \text{otherwise} 
\end{cases}
\]

Some champions are considered damage dealers, they deal very high damage, but die easily. Other champions deal very little damage, but can be almost impossible to kill, these are considered tanks. These two types of champions are weak when alone, but when they team up, they can pose a serious threat. The tank can be used by the damage dealer as a living shield, allowing him to stay alive for much longer, thus deal more damage.
To capture the synergy between two champions on the same team, we will for each team need a feature that represents the presence or absence of every 2-combination of champions on that team. Therefore, we define a feature $x_\text{PAIR}(t, c_1, c_2)$ such that $\forall t \in T, \forall c_1, c_2 \in C$ where $c_1 < c_2$:
\[
x_\text{PAIR}(t, c_1, c_2) =
\begin{cases}
  1 & \text{if } (c_1, p_1), (c_2, p_2) \in t \text{ for some }p_1, p_2\\
  0 & \text{otherwise}
\end{cases}
\]

We make the restriction $c_1 < c_2$, because we want to ignore permutations. This is because the two features $x_\text{PAIR}(t, c_1, c_2)$ and $x_\text{PAIR}(t, c_2, c_1)$ are the same, since they both capture that the two champions $c_1$ and $c_2$ are present on team $t$.

Some champions may have an advantage when fighting against a particular opponent.
For instance, a champion that is good at dodging ranged attacks is good against an enemy that only has ranged attacks.
We say that the better suited champion \emph{counters} the other.
To capture that one champion may counter another, we will for each champion on team $t$ need a feature that represents the presence or absence of every possible champion on the other team.
We define a feature $x_\text{COUNTER}(c_1, c_2)$ such that $\forall c_1, c_2 \in C:$
\[x_\text{COUNTER}(c_1, c_2) = 
\begin{cases} 
1 & \text{if } (c_1, p_1) \in T_\text{blue} \text{ and } (c_2, p_2) \in T_\text{purple} \text{ for some } p_1, p_2 \\ 
0 & \text{otherwise} 
\end{cases}\]

In this case, we do not have the restriction $c_1 < c_2$ and thus consider permutations instead of combinations.
To understand why, consider that $c_1$ counters $c_2$.
In this case, the feature $x_\text{COUNTER}(c_1, c_2) = 1$ is favorable to the blue team, while $x_\text{COUNTER}(c_2, c_1) = 1$ is favorable to the red team.
Note that in some game modes, $x_\text{COUNTER}(c_1, c_2) = 1$, where $c_1 = c_2$ is allowed. That is, the same champion may appear on both teams.
In that way we can capture if a champion can counter itself due to some asymmetries in the map layout.

In LoL, players can compete in ranked games, where they are placed in one of 7 tiers. Better players achieve higher tiers.
Before a match starts, we have access to data about the highest tier each player has achieved in a ranked game, which we will refer to as the rank of a player. We also know if a player has not competed in ranked games, in which case we say that he is unranked.
A player can achieve one of the ranks \textit{bronze}, \textit{silver}, \textit{gold}, \textit{platinum}, \textit{diamond}, \textit{master}, \textit{challenger} (mentioned in increasing order of skills required to achieve the rank).
We define a score function $\varphi : P \rightarrow \mathcal{N}$, where $\varphi(p) = 0$ if $p$ is unranked, or $1, 2, \dots, 7$ if $p$ has rank \textit{bronze}, \textit{silver}, $\dots$, \textit{challenger} respectively.
We define the rank of a team to be the average rank of all players on that team who is not unranked:
\[
\eta(t) = \frac{\sum\limits_{(p, c) \in t} \varphi(c)}{|\{(p, c) \in t \mid \varphi(p) > 0\}|}
\]
which we use to define a single feature
\[
x_\text{BEST-RANK} = 
\begin{cases} 
  1 & \text{if } \eta(T_\text{blue}) > \eta(T_\text{purple})\\
  -1 & \text{if } \eta(T_\text{blue}) < \eta(T_\text{blue})\\
  0 & \text{otherwise} 
\end{cases}
\]

The assumption that each tier can be mapped to a score on a linear scale may not be entirely on spot.
Therefore, another type of feature is introduced that captures the exact rank of each player.
$\forall(p, c) \in T_\text{blue} \cup T_\text{purple}$, we define a feature
\[
x_\text{PLAYER-RANK
}(p) = S(p)
\]


\subsection{Feature sparsity}\label{sec:featuresparsity}
The size of $x_{\text{SINGLE}}$ is $|T| \cdot |C| = 2 \cdot 124 = 248$. In each match, only $2 \cdot 5 = 10$ of those features appear.
The size of $x_{\text{PAIR}}$ is $|T| \cdot |C| \cdot (|C|-1) / 2 = 2 \cdot 124 \cdot 123 / 2 = 15252$. In each match, only $2 \cdot 5 \cdot 4 / 2 = 20$ of those features appear.
The size of $x_{\text{COUNTER}}$ is $|C|^2 = 124^2 = 15376$. In each match, only $\cdot 5 \cdot 5 = 25$ of those features appear.
The size of $x_{\text{BEST-RANK}}$ is 3. In each match, only $1$ of those features appear.
The size of $x_{\text{PLAYER-RANK}}$ can be calculated as follows. Each feature in $x_{\text{BEST-RANK}}$ represents a mean of $5$ values between $0$ and $7$ (both included). All possible means can be listed in increasing order as $\frac{0}{1}, \frac{6}{5}, \cdots, \frac{35}{5}$, in total $36$ features, whereas only $1$ appear in each match.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
